\chapter{Структура программы}
\label{cha:ch_2}

Программа написана на популярном языке программирования Python с использованием ООП~\footnote{(Объектно-ориентированное программирование) — методология программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов, каждый из которых является экземпляром определённого класса из~\cite{oop-buch}}.  Главная задача при написании кода заключалась в создании расширяемого и чистого кода, который я смогу в любой момент смогу изменить под свои нужды

Вот список файлов и папок, содержащихся в главной директории, а также несколько предложений описывающих их цель:

\section*{\texttt{run.py}}

Файл запускающий проект.  Сам этот модуль не содержит особенного важного кода, он просто содержит пару import'ов из модуля \texttt{runner}, имеет своё название, чтобы подходить принятому интерфейсу програм написанных на Python, работающих через командную строку. Пользователь может запустить один из сценариев, описанных ниже, используя терминал.  Например чтобы запустить telegram бота, находясь в главной папке проекта, надо воспользоваться следующей командой в терминале:

\begin{verbatim}
python run.py bot
\end{verbatim}

\section*{\texttt{runner}}

Модуль определяющий точки запуска проекта.  В ней содержатся реализации классов определяющие следующие сценарии работы програмы:

\begin{itemize}
\item \texttt{bot}

Запуск telegram бота.  Самый стандартный сценарий работы.  Чтобы бот работал, необходимо поменять значение переменной \texttt{BOT\_TOKEN}, на токен бота, который вы можете взять у другого telegram бота \emph{@BotFather}, подробнее о создании telegram ботов в статье~\cite{tg-bots}.  Советую менять переменные окружения, используя файл \texttt{.env}~\footnote{подробнее в главе статьи \cite{dotenv}}

\item \texttt{server}

Запуск Rest API сервера~\footnote{подробнее о Rest API сервисах в книге \cite{rest-api}}.  Полезно для разработчиков на других языках программирования, если вы из таких, и вам необходим предоставленный мною материал, советую ознакомится.

\item \texttt{shell}

Это аналог telegram бота, только без использования telegram'а, вместо запуска telegram бота, пользователю будет предоставлена типичная для консольных приложений оболочка.
\end{itemize}

\section*{\texttt{entities\_formatter.py}, \texttt{handlers.py}, \texttt{abstract\_ui.py} из \texttt{ui}}

Если вы уже полностью протестировали программу, то могли понять, что telegram бот и консольная оболочка имеют почти один и тоже интерфейс, так и есть.  Внутри кода это устроено таким образом: классы бота и оболочки реализуют все методы необходимые для работы \texttt{abstract\_ui}, используя методы из \texttt{handlers}, в них входят следующие функции: отправка сообщения {}<<старт>>{}, отправка обычного сообщения, отправка сообщения об ошибке, однако сообщения методы \texttt{handlers} не создаёт, этим занимается \texttt{abstract\_ui} и \texttt{entities\_formatter}, первый готовит сырую информацию, чтобы прислать сообщения, а второй переводит понятной для нужной платформы формат (например формат сообщений telegram с использованием их языка разметки, то есть я могу, например, спокойно выделять жирным шрифтом любой кусок текста, подробно о языке разметки telegram сообщений в статье~\cite{tg-markdown}).

Возможно вам такая система могла показаться лишней, однако при таком устройстве я точно могу быть уверенным, что если я захочу написать код, например для VK, то мне будет необходимо реализовать лишь три метода и форматирование сообщения, это займёт полчаса максимум.  А если я захочу изменить поведение бота, то мне не придётся править код для всех платформ, на которых он должен работать, а изменить лишь код \texttt{abstract\_ui}.

\section*{\texttt{ui/tg\_bot.py}, \texttt{ui/console\_ui.py}}

Реализация бота и консольной оболочки

\section*{\texttt{dto.py}}

Здесь определяются модели (dto~\footnote{(Data Transfer Object) --- шаблон проектирования, используется для передачи данных между подсистемами приложения, не содержащий какого-либо поведения}) для главных сущностей данного проекта:

\begin{itemize}
\item Исполнитель (Artist)
\item Альбом (Album)
\item Трек (Track)
\end{itemize}

Здесь слово <<модели>> обозначает лишь структуру, то есть это такие классы, которые ничего не могут кроме хранения информации.  Таким образом всё что может класс модели \texttt{Album}, это сохранять имя альбома, имя исполнителя и год его релиза

\section*{\texttt{music\_manger}}

Здесь определяются классы, общающиеся с различными музыкальными сервисами.

Эти реализации возвращают объекты классов из модуля \texttt{dto}.

\section*{\texttt{music\_manager/implementation/rocknation\_and\_spotify}}

Это реализация \texttt{music\_manager}'а для совместной работы spotify и rocknation.  Несмотря на закрытие spotify, моя реализация спокойно работает.

\section*{\texttt{music\_manager/implementation/directory\_music\_manager}}

Это реализация \texttt{music\_manager}'а для работы с пользовательской папкой mp3 файлов

\section*{\texttt{entities}}

Здесь определяются 3 класса: \texttt{Artist}, \texttt{Album}, \texttt{Track}.  Это обёртки над \texttt{music\_manager}'ами, позволяющая удобно взаимодействовать разработчику с библиотекой музыки